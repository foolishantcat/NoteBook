# 经典算法学习笔记

[TOC]

本笔记记录了本人在学习经典算法的时候的一些学习笔记。

主要参考文献《算法图解》，顺便推荐一下，这是一本非常不错的经典算法书籍，阅读基本无门槛。

学习算法，很容易遇到以下问题：

1. 很多经典算法在以前都学习过，或者接触过，但是一段时间不实际使用，就容易被人遗忘了
2. 对算法囫囵吞枣，自以为自己懂了，但是实际未知全貌
3. 对算法理解停留在表面，所以不知其内里的思想，遇到问题不能举一反三

想要解决上述三个问题，需要对症下药，各个击破。

1. 第一个问题，也是我觉得本笔记可以实际解决的问题，对所学算法做笔记，方便回顾和理解
2. 这个得靠自己，看各人
3. 这个得靠自己，看各人

下面就逐一介绍一下，一些遇到的经典算法。



## NP完全问题

什么是NP完全问题呢？

想要理解什么是NP完全问题，那就需要先了解什么是NP问题

**`NP问题`**：就是`Non-deterministic Polynomial`的问题，也即是多项式复杂程度的非确定性问题。

而如果任何一个NP问题都能通过一个多项式时间算法转换为某个NP问题，那么这个NP问题就称为：**`NP完全问题`**（Non-deterministic Polynomial complete problem）。NP完全问题也叫NPC问题[^摘自百度百科]。

一个经典的NP完全问题：**旅行商问题**

> 城市数
>
> 1			->		1条路线
>
> 2			-> 		2个可能的出发城市x每个出发城市1条可能的路线=2条可能的路线
>
> 3			->		 3个可能的出发城市x每个出发城市2条可能的路线=6条可能的路线
>
> 4			-> 		4个可能的出发城市x每个出发城市6条可能的路线=24条可能的路线
>
> 5			-> 		5个可能的出发城市x每个出发城市24条可能的路线=120条可能的路线

涉及到6个城市时，可能的路线有多少条呢？如果你说720条，那就对了。7个城市为5040条，8个城市为40320条。

这个称为`阶乘函数（factorial function）`，因此，如果涉及的城市非常多，根本就无法找出旅行商问题的正确解。

旅行商问题和**`集合覆盖问题`**[^请自行百度]，有一些共同之处：你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。

对于旅行商问题来说，什么样的近似算法不错呢？能找到较短路径的算法就算不错。

比方说，我们会采取这样的做法：随便选择出发城市，然后每次选择要去的下一个城市时，都选择还没去过的最近的城市。假设旅行商从马林出发：

> 马林	--10英里-->	旧金山	--14英里-->	伯克利	--31英里--> 	弗里蒙特	--16英里--> 	帕洛阿尔托

总旅程为71英里。这条路径可能不是最短的，但也相当短了。

NP完全问题的简单定义是：以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。

假如没有办法判断问题是不是NP完全问题，还有一些蛛丝马迹可循的：

- 元素较少时算法运行速度非常快，但随着元素数量的增加，速度会变得非常慢
- 涉及“所有组合”的问题通常是NP完全问题
- 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。
- 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题
- 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题
- 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题



## 背包问题

属于一种动态规划问题，假设：可以偷窃三件商品，三件商品分别价值如下

- 音响，3000美元，4磅
- 笔记本电脑，2000美元，3磅
- 吉他，1500美元，1磅

为了让盗窃的商品价值最高，该怎么选择？

这是一个经典的背包问题，选择合适的物品（在背包限重的条件下），达到背包里面物品总价值最大。

可供选择的算法有两个：

- 简单算法

- 动态规划

### 简单算法

最简单的算法：尝试各种可能的商品组合，并找出价值最高的组合。

这种方法，可行，但是速度非常慢，只要商品数量多到一定程度，这种算法就行不通。因此一般实际工程，不推荐用这种方法。

### 动态规划

动态规划采用将大问题拆分成小问题的思路，动态规划先解决子问题，再逐步解决大问题。对于背包问题，你先解决小背包（子背包）问题，再逐步解决原来的问题。

比如，一个最多能装4磅重的背包，被划分成1，2，3，4磅重的子背包所组成的大背包。

为了可以更加直观的体现动态规划算法，我们使用网格演示过程。

|                             | 1    | 2    | 3    | 4    |
| --------------------------- | ---- | ---- | ---- | ---- |
| 吉他（1磅，1500美元）       | 1500 | 1500 | 1500 | 1500 |
| 音响（4磅，3000美元）       | 1500 | 1500 | 1500 | 3000 |
| 笔记本电脑（3磅，2000美元） | 1500 | 1500 | 2000 | 3500 |

按照行为单位，遍历所有重量的子背包所能装下的物品所能达到的最大价值。

例如：

- 吉他行，遍历所有子背包（当前只能装吉他）：

1. 若1磅重的子背包，装1磅的吉他，最大收益1500
2. 若2磅重的子背包，装1磅的吉他，最大收益1500
3. 以此类推，3和4磅重的背包，装1磅的吉他，最大收益1500

- 音响行，遍历所有子背包（当前可以装吉他、音响）

1. 音响有4磅重，所以除开4磅的背包，其他背包都只能装1磅的吉他，最大收益1500
2. 若4磅重的子背包，装4磅的音响，收益为3000，大于该背包的前任最大收益1500，更新4磅背包的最大收益

- 笔记本电脑行，遍历所有子背包（当前能装吉他、音响、笔记本电脑）

1. 1和2磅重的背包，只能装的下1磅重的吉他，所以最大收益1500不变
2. 3磅重的背包，可以装的下笔记本电脑，收益为2000，大于此前的1500
3. 4磅重的背包，可以装得下笔记本电脑+吉他，收益为3500，大于此前的3000

经过三轮遍历，发现最终所有子背包的收益最大值被更新到3500（笔记本电脑+吉他的组合）

可以从以上的迭代过程中，抽象出背包问题动态规划算法的迭代公式：
$$
{CELL}[i][j] = 两者中较大的那个 \{^{1. 上一个单元格的值（即CELL[i-1][j]的值）}_{2. 当前商品的价值+剩余空间的价值}
$$
有的同学可能会说，以上三种物品的选择先后顺序打乱，会不会影响到最终的结果？

**答案是：不会的，也就是说动态规划算法各行的排列顺序是无关紧要的**

把以上结论延伸一下：**动态规划算法，支持分布式/多线程并行。**

动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。**仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。**

一般来说，一个问题要抽象成为一个动态规划问题，需要思考三个问题：

- 单元格中的值是什么？
- 如何将这个问题划分为子问题？
- 网格的坐标轴是什么？

动态规划，还通常用于解决“最长公共字符串”的问题，与背包问题的区别之处在于，问题的答案，并不在最后一个“单元格”中（背包问题的最终答案总是在最后的单元格中），最长公共子串的答案为网格中最大的数字，它可能并不位于最后的单元格中。



## K邻近算法

K邻近算法（K- Nearest Neighbor）也叫KNN算法，主要用于解决两大问题：**分类、回归**。

我将按照以下顺序来介绍K邻近算法，是如何完成**分类和回归**的。首先，介绍分类，这个问题也是，日常生活中比较常见的问题。

### 分类

比如：需要从一堆水果中区分出橙子还是柚子。我们知道柚子通常比橙子更大、更红。

把水果的颜色和个头分为作为直角坐标系的x和y轴，所有的水果均可以以平面点的方式画到直角坐标系。

这时我们一般会发现，柚子更大，更红。这个水果又大又红，因此很可能是柚子。在坐标轴上的表现一般是，柚子更加偏向右上角，橘子更加偏向左下角。

好的，那么问题来了在橘子和柚子在左表轴上可以分得很开的前提下，如果出现中间地带的水果，我们应该如何判断这个水果是橙子还是柚子呢？

这是一个典型的二分类问题！

这时候我们就可以使用K-最近邻算法，该算法的核心思想：计算K个与当前目标“距离”上最邻近的K个对象，并利用占比最多的对象类型来确定目标对象类型。

这个算法非常简单，但是，同时它也非常有用。当要对东西进行分类时，可首先尝试这种算法。

你甚至可以用K最邻近算法，构建一个简单的推荐系统。

### 推荐系统

假设Netflix（网飞），要为用户创建一个电影推荐系统。从本质上来说，这类似于前面的水果问题。你可以将所有的用户都放到一个直角坐标系里面。当然，前提是，你已经抽取了分类所需的喜好特征。

这些用户在图表中的位置取决于其喜好，因此喜好相似的用户距离较近。

在计算相似度的过程中，我们的准则是“距离”越近的两者间，相似度越高。

比较简单的距离计算公式：

A用户：$（x_1,y_1）$

B用户：$(x_2,y_2)$

A和B的距离如下：$\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}$

当A和B的维度高于二维的时候这个距离公式任然适用，不过此时计算的距离不是二维空间中A和B的距离，而是多维空间中A和B的距离。

A用户：$（x_1,y_1,z_1,\dots）$

B用户：$(x_2,y_2,z_2,\dots)$

A和B的距离如下：$\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2 + (z_1-z_2)^2 + \dots}$



### 回归

回归问题，简单可以介绍为，假设你不仅要向F用户推荐电影，还要预测她将给这部电影打多少分。为此，先找出与她最近的5个人。

顺便说一句，其实并非一定要选择5个最近的邻居，也可选择2个、10个或10000个。

假设要预测F用户会给电影打多少分。A、B、C、D、E分别给了：

A：5分

B：4分

C：4分

D：5分

E：3分

求出这些人打分的平均值，结果为4.2。这就是**回归（regression）**。所以通常KNN算法用于做两项基本工作--**`分类`**和**`回归`**：

- 分类就是编组；
- 回归就是预测结果（如一个数字）

回归很有用。假设你开了一家小小的面包店，每天都做新鲜面包，需要根据如下一组特征预测当天该烤多少条面包：

- 天气直属1~5（1表示天气很糟糕，5表示天气非常好）
- 是不是周末或节假日（周末或节假日为1，否则为0）
- 有没有活动（1表示有，0表示没有）

你还有一些历史数据，记录了在各种不同的日子里售出的面包数量。

因此，可以看出，这构成了一个非常简单机器学习的**特征和标签**。

今天是周末，天气不错。根据这些数据，预测你今天能售出多少条面包呢？我们使用KNN算法，其中K为4。首先找出与今天最接近的4个邻居。假如今天为点G，计算所有样本与G点的距离，最近的6个点为：

A：1（300条）

B：2（225条）

C：3（75条）

D：1.41（200条）

E：1（150条）

F：2.23（50条）

将这些天出售的面包数平均，结果为218.75条。

>前面计算两位用户的距离时，使用的都是距离公式。虽然距离公式适用范围很宽，比如A*算法也通常使用直线距离作为估计函数，但是还有更合适的公式吗？在实际工作中，经常使用`余弦相似度（cosine similarity）`。假设有两位品味类似的用户，但其中一位打分时更保守。他们都很喜欢Manmohan Desai的电影$Amar Akabar Anthony$，但Paul给了5星，而Rowan只给了4星。如果你使用距离公式，这两位用户可能不是邻居，虽然他们的品味非常接近。
>
>余弦相似度不计算两个矢量的距离，而比较他们的角度，因此更适合处理前面所说的情况。因此，如果你要使用KNN，那么一定会使用到余弦相似度计算。



### 如何挑选合适的特征

特征的选取，在做回归问题上，是相当重要的一个环节，不合理的特征，可能会让你的回归模型几乎丧失预测能力。

在推荐系统的例子上，假设电影推荐中，你只让用户给《玩具总动员》《玩具总动员2》《玩具总动员3》打分。这将难以让用户的电影欣赏品味显现出来。所以说，KNN算法挑选合适的特征进行比较至关重要。合适的特征有以下两个方面：

- 与要推荐的电影紧密相关的特征；
- 不偏不倚的特征（例如，如果只让用户给喜剧片打分，就无法判断他们是否喜欢动作片）

回答面包店的例子：对于面包店，你能找出两个不错和糟糕的特征吗？

在报纸上打广告后，你可能需要烤制更多的面包；

或者，每周一你都需要烤制更多的面包。

其实，背后的本质都是基于人类的先验知识，具备一定的主观性。

所以，在挑选合适的特征方面，没有放之四海皆准的法则，你必须考虑到各种需要考虑的因素。



## 拍卖算法

拍卖算法，是最近工作中使用到的一个比较经典的算法，如果对我本人的描述看不明白的，可以直接看目前已经有的几个博客：

[论文解释](http://www.docin.com/p-730024917.html)

[附代码迭代](https://blog.csdn.net/vict_wang/article/details/86584435)

[最生动的算法解析](https://blog.csdn.net/Anker_Evans/article/details/106539488)

[论文考古](http://web.mit.edu/dimitrib/www/Orig_Auction.pdf)

值得一提的是这篇名为：`A Distributed Algorithm for the Assignment Problem`的论文，是$Dimitri P. Bertsekas$在1979年的论著。这篇论文是拍卖算法的开山之作，其后出现的拍卖算法，都是基于该论文的进化版本，虽然历经了几十年，但是该算法依然是非常实用的算法。

有兴趣的朋友，可以自行阅读论文英文原文，不过不得不说，真的是有点晦涩难懂。

那么下面，我就以我个人的看法简单阐述一下，如何使用拍卖算法，只能说是使用，论文原文的推理过程，其实我也没有完全看懂。

> 拍卖算法解决的根本问题可以概括为：当有N个人，需要对M件物品进行选取时，其中每个人分别对M件物品有不同的幸福值（可以理解为利润，但是我更倾向于理解为幸福值，因为喜欢一样东西，跟价格无关）。
>
> 为了让所有人的幸福值总值最高，人和物品应该怎么匹配？

当然，论文论证了，算法需要正常运行，需要N=M成立。

之所以被称为拍卖算法（Auction），原因是论文也引用了物品拍卖的场景，解释了该分配算法（Assignment）。但是实际上，有两点是不符合拍卖常理的：

1. 拍卖为价高者得，而拍卖算法为确保每个人都拍到意见物品为目的
2. N必须等于M，而实际拍卖是没有这个问题的

由此可见，拍卖算法，只是利用了拍卖的场景，以及利用了一个中间变量（**`价格`**），完美的将物品一对一的分配到每个人。

拍卖算法，限定了**`收益计算公式`**：

> $profit = value - price$

收益计算公式中，人选择物品，总是会选择收益最高的物品。

拍卖算法，限定了**`报价计算公式`**：

> $price_{old} \leq price_{new} \leq price_{old} + π + \epsilon$

在这个公式中

>  $\pi = \alpha_{ij} - p_{j} - (\alpha_{ik} - p_{k})$

>  $\epsilon \leq \frac{1}{N}$，满足该条件，则算法结束时获得最优解，该偏移量越大，算法迭代次数越少

简单言之：当前物品的价格，出价为物品的老的价格加上本次选择中最大收益减去次大收益的差值(**$\pi$**)，然后再加上一个偏移量(**$\epsilon$**)。

当然，当一轮分配结束之后，会遇到两种情况：

- 每个人都获得分配（算法停止）
- 每个人购买所有物品的最大收益都不大于0（这种情况比较极端）

所以，最终分配结束的状态应该是：**`每个人都获得了合理的分配，且不冲突`**。

这里需要注意的一点是，每次每人出价完了之后，需要更新价格到物品。下一人看到该价格的时候，价格已经被更新，需要用新的价格计算收益（幸福值）。

以下是拍卖算法的迭代过程：

1. 初始价格为0，计算当前收益，选取最大收益物品
2. 给最大收益物品定价，更新价格
3. 查看是否还有没有分配的人，如果有则计算收益，更新价格
4. 查看是否分配有冲突，如无，则算法结束；有则重复迭代（重复迭代，需要将已经单独分配的考虑进来）
5. 一直到无分配冲突，获得最优解，算法结束

因为markdown不太适合绘图，在已经理解拍卖算法的基础上，我就不附图了，需要更加深入的了解算法，建议直接代码实现一遍拍卖算法。