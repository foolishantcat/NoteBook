# MQ消息队列

## 功能介绍

消息队列就是基础数据结构中“先进先出”的一种数据结构。

### 解决什么问题

MQ是一直存在的，不过随着微服务架构的流行，成了解决微服务之间问题的常用工具。

### 应用解耦

以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统除了故障，都会造成下单操作异常。

当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统会因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障。提升系统的可用性。

### 流量消峰

举个栗子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。

使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这使有些用户可以在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。

### 消息分发

多个服务对数据感兴趣，只需要监听同一类消息即可处理。

### 异步消息

有些服务间的调用是异步的，例如A调用B，B需要花费很长时间执行，但是A需要知道B什么时候可以执行完，以前一般有两种方式，A过一段时间去调用B的查询API查询。或者A提供一个callback API，B执行完之后调用API通知A服务。这种方式都不是很优雅。

使用消息总线，可以很方便解决这个问题，A调用B服务后，只需要监听B处理完成的消息，当B处理完成后，会发送一条消息给MQ，MQ会将此消息转发给A服务。

这样A服务既不用循环调用B的查询API，也不用提供callback API。同样B服务也不用做这些操作，A服务还能及时得到异步处理成功的消息。

### 