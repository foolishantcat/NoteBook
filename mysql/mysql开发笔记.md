MySQL开发笔记

本笔记记录使用mysql过程中遇到的一些知识点，笔记均来自互联网。

## mysql操作分类

- DDL：数据库定义语言，定义数据库对象（库、表、列、索引）的操作
- DML：数据库操作语言，定义对数据库记录的操作（insert、delete、update、select）
- DCL：数据控制语言，定义对数据库、表、字段、用户的访问权限和安全级别（授权grant等）

## mysql主键分类

### 主键的作用

- 保证表的完整
- 保证表数据行的唯一性质

### 业务主键（自然主键）

在数据库表中把具有业务逻辑含义的字段作为主键，称为“自然主键（Natural Key）”。

自然主键的含义就是原始数据中存在的不重复字段，直接使用称为主键字段，这种方式对业务的耦合太强，一般不会使用。

### 逻辑主键（代理主键）

在数据库表中采用一个与当前表中逻辑信息无关的字段作为其主键，称为“代理主键”。

逻辑主键提供一个与当前表数据逻辑无关的字段作为主键，逻辑主键被广泛使用在业务表、数据表，一般有几种生成方式：uuid、自增。

其中使用最多的是自增。

逻辑主键成功的避免了主键与数据表关联耦合的问题，与业务主键不同的是，业务主键的数据一旦发生更改，那么那个系统中关于主键的所有信息都需要连带修改，这是不可避免的，并且这个更改是随业务需求的增量而不断的增加、膨胀。

而逻辑主键和应用耦合度低，它与数据无任何必要的关系，你可以只关心：第一条数据；而不用关心：名字是a的那条数据。某一天名字改成b，你还是只关心：第一条数据。

业务更改几乎是不可避免的，前期任何产品经理言之凿凿的不修改论调都是不可靠、不切实际的。我们必须考虑主键数据在更改的情况下，数据能否平稳度过危机。

### 复合主键（联合主键）

通过两次或者多个字段的组合作为主键。

符合主键可以说是业务主键的升级版本，通常一个业务字段不能够确定一条数据的唯一性，例如：张三的身份证是223222，张三这种大众名称100%会出现重复。我们可以用姓名+身份证的方式表示主键，声明一个唯一记录。

有时候，复合主键是复杂的。姓名+身份证在业务上可能不一定能表示不重复，虽然身份证在17年消除了重复的问题。可能我们需要新增一个地址作为联合主键，为了去除业务复杂度增加带来的唯一性问题，这会让主键变得很臃肿，复杂度陡升。

另外，如果其他表要与该主键关联，则需要引用复合主键的所有字段，这就不单纯是性能问题了，还有存储空间的问题了，当然你也可以认为这是合理的数据冗余，方便查询，但是感觉有点得不偿失。

使用复合主键的原因可能是：对于关系表来说，必须关联两个实体表的主键，才能表示它们之间的关系，那么可以把这两个主键联合组成复合主键即可。

如果两个实体存在多个关系，可以再加一个顺序字段联合组成复合主键，但是这样就会引入业务主键的弊端。当然，也可以另外对这个关系表添加一个逻辑主键，避免了业务主键的弊端，同时也方便其他表对它的引用。

### 性能对比

根据网络上的网友的实际测试，得出结论：

- 复合主键的数据插入是线性增长的

当数据小于100w，插入常在5s/w左右，当数据变大，插入时长无限变大，当数据达到1000w时，平均插入1w条数据已经达到15秒。

每增加一条数据，复合主键都需要判断是否重复，数据量一旦增大，每次新增都需要筛查全表。

- 查询效率

另外，逻辑主键+索引的方式，占用空间比复合主键多出一倍左右，但是实际查询体验，索引查询效率更高，所以索引应该是首选。

- 符合主键是否应该选择？

在业务主键字段不超过2-3个的情况下，需要确保数据维度的唯一性，采取符合主键加上限制，是可取的。

### 我的建议

| 数据           | 业务     | 建表选择                         |
| -------------- | -------- | -------------------------------- |
| 数据量小       | 业务简单 | 随便                             |
| 数据量小       | 业务复杂 | 逻辑主键                         |
| 数据量大       | 业务简单 | 业务主键+索引<br>或复合主键+索引 |
| 数据量大       | 业务复杂 | 逻辑主键+索引                    |
| 数据量超过千万 | *        | 逻辑主键+索引                    |

业务复杂，表示主键唯一性规则扩展需求旺盛



## mysql key分类

mysql中的key（索引）在B树种存储，各种key本身就是索引。

索引主要用于：

1. 快速找出匹配的一个where字句行
2. 当执行联结时，从其他表检索行
3. 对特定的索引列找出MAX()或MIN()值
4. 如果排序或分组，在一个可用键的最左前面加上前缀进行排序，或者分组一个表（例如：order by key_part_1, key_part_2）
5. 如果所有键值部分跟随DESC，键以倒序被读取
6. 在一些情况下，一个查询能被优化来检索值，不用咨询数据文件
7. 如果对某些表的所有使用的列是数字型，并且构成某些键的最左边前缀，为了更快，值可以从索引树被检索出来

下面是对比不同key的分类：

- primary key（主键）

这个我就不多介绍了，表数据行唯一标识

- foreign key（外键）

表示该字段，是其他表的主键（这个功能总感觉有点鸡肋）

- unique key（唯一约束）

该列数据必须唯一

- key（键）

普通索引，mysql的key和index多少有点令人迷惑，单独的key和其他关键词结合的key（primary key）实际表达的意义是不同的。

key是数据库的物理结构，它包含两层意义：

1. 约束（偏重于约束和规范数据库的结构完整性）
2. 索引（辅助查询用）

key通常是index同义词，这么做的目的是与其他数据库系统兼容

- index（索引）

简而言之，提升某列的查询速度，建立索引。



## INT和INTEGER区别

没区别，INT是INTEGER的简写



## NOT NULL和DEFAULT

- NOT NULL

表示非空约束，也就是不能向表里面插入空值

- DEFAULT

是在不给字段输入时（插入操作，字段不赋值），默认返回结果

- NOT NULL和DEFAULT能不能混用

答案是可以，但是他们不会同时生效

NOT NULL在插入“NULL”时生效

DEFAULT在字段不赋值的时候生效

**所以not null 和 default是两个独立的约束，可以用在一个字段上，但不会交互使用，是两个独立的约束条件。另外约束条件不仅是在插入数据时有用，当我们在对表数据进行修改时，也会受到约束条件的限制。**



## 如何从外部导入csv文件数据

使用`mysqlimport`

```mysql
mysqlimport -u app -p --local testdb testtable --lines-terminated-by="\r\n" --fields-terminated-by="," --fields-optionally-enclosed-by='"' --ignore-lines=1
```

- --local表示从本地导入
- --lines-terminated-by表示行以什么结尾
- --fields-terminated-by表示字段以什么分割
- --fields-optionally-enclosed-by表示字段以什么包围
- --ignore-lines表示忽略从文件开头算起的多少行
- testtable表示本地文件名

这里需要注意，为了避免出现一些字段错位，我们通常将本地文件的名称修改为数据库的表名，本地文件的列顺序，需要和mysql数据表的字段顺序一致。



## 如何将mysql数据导入到外部csv文件

使用`mysql`

```mysql
mysql -u app --password=XXXX --database=XXXX -Ne"select fields from testtable" > local_file.csv
```

该方法导出的csv文件，以`TAB`符分割列，并且不包含表头。



## TIMESTAMP和DATE

DATE只保存日期，不保存时分秒。

TIMESTAMP类型保存的值不能比1970早或比2037晚，这意味着，一个日期例如'1968-01-01'，当作为一个DATETIME或DATE值合法时，它不是一个正确TIMESTAMP值，并且如果赋值给这样一个对象，他将被变换到0.

此外，对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。而对于DATETIME，不做任何改变，基本上是原样输入和输出。

以前MYSQL创建表的时候，timestamp类型的字段可以不加默认值。

```mysql
`createTime` timestamp COMMENT '创建时间'
```

这样创建是没有问题的。但是现在却报错，“Invalid default value for 'createTime'”

问题原因：因为MySQL 5.6以后timestamp设定默认值规则改变，不能为0000 00-00 00:00:00

查看网上解决方案是修改mysql安装目录下的my.ini文件。但是我不想改mysql配置。

解决方案：

```mysq
`createTime` timestamp NULL COMMENT '创建时间'
```



## mysql中存储emoji表情

在mysq5.7.19中，创建的数据库默认选择的编码是`utf8 -- UTF-8 Unicode`，因此字段默认的编码为`utf-8`，但在项目开发中存在一个需求；在某个字段中存储混有emoji表情的字符串，此时以普通编码格式`utf8`来存储emoji表情时，会报异常。

解决方案：把字段编码格式更改为`utf8mb4`。

顺便查了一下utf8和utf8mb4的区别：

- UTF-8编码中，一个英文字符占用一个字节的存储空间，一个中文（含繁体）占用三个字节的存储空间。
- UTF8MB4：MySQL在5.5.3之后增加了utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。因此可以用来存储emoji表情。



## mysql类型一览表

- 整形

tinyint（m）：1字节，范围（-128~127）

smallint（m）：2个字节，范围（-32768~32767）

mediumint（m）：3个字节，范围（-8388608~8388607）

int（m）：4个字节，范围（-2147483648~2147483647）

bigint（m）：8个字节，范围（+-9.22*10的18次方）

取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为（0~256）

int（m）里的m是表示select查询结果集中的显示宽度，并不影响实际的取值范围，没有影响到显示的宽度，不知道这个m有什么用

- 浮点型

float（m，d）：单精度浮点型，8位精度（4字节），m总个数，d小数位

double（m，d）：双精度浮点型，16位精度（8字节），m总个数，d小数位

设一个字段定义为float（5，3），如果插入一个数123.45678，实际数据库里存的是123.456，但总个数还是以实际为准，即6位

- 定点数

浮点数在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。

decimal（m，d）参数m<65是总个数，d<30且d<m是小数位。

- 字符串

char（n）：固定长度，最多255个字符

varchar（n）：固定长度，最多65535个字符

tinytext：可变长度，最多255个字符

text：可变长度，最多65535个字符

mediumtext：可变长度，最多2的24次方-1个字符

longtext：可变长度，最多2的32次方-1个字符

```
char和varchar区别：
1. char（n）若存入字符数小于n，则以空格补上其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此
2. char（n）固定长度，char（4）不管存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n<=255）或2个字节（n>255），所以varchar（4），存入3个字符将占用4个字节。
3. char类型的字符串检索速度要比varchar类型的快。
```

```
varchar和text的区别：
1. varchar可指定n，text不能指定，内存储varchar是存入的实际字符数+1个字节（n<=255）或2个字节（n>255），text是实际字符数+2个字节。
2. text类型不能有默认值。
3. varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text，在都创建索引的情况下，text的索引似乎不起作用。
```

- 二进制数据（Blob）

1. Blob和text存储方式不同，text以文本方式存储，英文存储区分大小写，而blob是以二进制方式存储，不分大小写。
2. blob存储的数据只能整体读出。
3. text可以指定字符集，blob不用也不能指定字符集。

- 日期时间类型

date：日期“2008-12-2”

time：时间“12：25：36”

datetime：日期时间“2008-12-2 22:06:44”

timestamp：自动存储记录修改时间

若定义个字段为timestamp，这个字段里的时间会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。

- 数据类型的属性

NULL：数据列可包含NULL值

NOT NULL：数据列不允许包含NULL值

DEFAULT：默认值

PRIMARY KEY：主键

AUTO_INCREAMENT：自动递增，适用于整数类型

UNSIGNED：无符号

CHARACTER SET name：指定一个字符集



## MySQL修改表结构

```mysql
ALTER TABLE {table_name} ADD COLUMN field_name VARCHAR(1) DEFAULT NULL COMMENT '增加一个字段demo';
ALTER TABLE {table_name} MODIFY COLUMN {field_name} VARCHAR(1) DEFAULT NULL COMMENT '修改字段的注释demo';
```



## 视图View使用

视图是一个**虚拟表**，是sql的查询结果，其内容由查询定义。同真是表一样，视图包含一系列带有名称的列和行数据，在使用视图时动态生成。视图的数据变化会影响到基表，基表的数据变化也会影响到视图[`insert` `update` `delete`]；创建视图需要`create view`权限，并且对于查询涉及的列有select权限；使用create or replace或者alter 修改视图，那么还需要该视图的drop权限。

- 视图的作用

1. 权限控制时

比如某几个列，允许用户查询，其他列不允许。

可以通过视图，开放其中一列或几列，起到权限控制的作用。

2. 简化复杂查询

查询每个栏目下商品的平均价格，并且按照平均价格排序，查出平均价格前3高的栏目

3. 视图能不能更新，删除，添加？

如果视图的每一行，是与物理表一一对应的，则可以。

view的行是物理表多行经过计算得到的结果，view不可以更新。

4. 大数据分表时可以用到

表行数超过200w行时，select速度会变慢。这时可以使用id取模，将一张表的数据存入4张表。

然后用一张视图包括4张表：

```sql
create view news as select from n1 union select from n2 union ...
```

- 视图的使用

1. 创建视图

```sql
create view 视图名 as select 字段名 from 表名;
```

MySQL视图的定义在from关键字后面，不能包含子查询

2. 修改了视图，对基表数据有影响
3. 修改了基表，对视图也有影响
4. 修改视图

```sql
alter view 视图名 as select 语句；
alter view 视图名 as select 视图；
```

5. 显示视图创建情况

```sql
show create view 视图名;
```

6. 查看视图

```sql
show tables;
show table status [from db_name] [like 'pattern'];
select * from information_schema.views where table_name = 'my_view';
```

7. 删除视图

```sql
drop view 视图名,[视图名...];
```

8. 重命名视图

```sql
Rename table 视图名 to 新视图名;
```

- 使用视图的好处

1. 安全
2. 性能。避免使用JOIN查询数据
3. 灵活。如果系统中有一张旧的表，这张表由于设计问题，即将被废弃。然后，很多应用都是基于这张表，不易修改，这时就可以建立一张视图，视图中的数据直接映射到新建的表。这样，就可以少做改动，也达到了升级数据表的目的。



## 联表删除

希望删除t1表中，在t2表中已经存在，或者不存在的数据，这就叫联表删除。

```sql
delete t1
from t1 left join t2
on t1.id_1 = t2.id_1
where t2.id_2 is null
```

上面的语句的意思就是：删除t1表中在t2表中不存在的数据

如何给上面的语句设置别名？

```sql
delete a
from t1 as a left join t2 as b
on a.id_1 = b.id_1
where b.id_2 is null
```

如果你为一个表声明了别名，`当你的删除动作指向这个表的时候，就必须使用这个别名`。

此外，在多个表联合删除时，不能使用`order by`或`limit`，单个表的删除时就没有这个限制。

当前，我们还不能在删除表的时候，在子查询中`select from`相同的表。























